{"version":3,"file":"fjl-mutable.mjs","sources":["../../src/fjlMutable.js"],"sourcesContent":["/**\r\n * @module fjlMutable\r\n * @note Custom jsdoc type definitions defined toward end of file.\r\n */\r\nimport {isUndefined, curry, apply, isType, errorIfNotType} from 'fjl';\r\n\r\n/**\r\n * Creates `defineProps` and `defineEnumProps` methods based on `{enumerable}` param.\r\n * @param {{enumerable: Boolean}}\r\n * @returns {function(*, *)|PropsDefinerCall}\r\n * @private\r\n */\r\nfunction createDefinePropsMethod ({enumerable}) {\r\n    const operation = enumerable ? defineEnumProp : defineProp;\r\n    return (argTuples, target) => {\r\n        argTuples.forEach(argTuple => {\r\n            const [TypeRef, propName, defaultValue] = argTuple;\r\n            apply(operation, [TypeRef, target, propName, defaultValue]);\r\n        });\r\n        return target;\r\n    };\r\n}\r\n\r\nexport const\r\n\r\n    /**\r\n     * Creates a descriptor for a property which is settable but throws\r\n     * errors when the `Type` is disobeyed.\r\n     * @function module:fjlMutable.createTypedDescriptor\r\n     * @param Type {TypeRef} - {String|Function}\r\n     * @param target {*}\r\n     * @param propName {String}\r\n     * @returns {Descriptor} - Property descriptor with just getter and setter.\r\n     */\r\n    createTypedDescriptor = (Type, target, propName) => {\r\n        let _value;\r\n        return {\r\n            get: function () {\r\n                return _value;\r\n            },\r\n            set: function (value) {\r\n                _value = errorIfNotType(Type, propName, target, value);\r\n            }\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns a target-descriptor tuple whose 'descriptor' will be set to\r\n     *  enumerable (`enumerable: true`).\r\n     * @function module:fjlMutable.toEnumerableDescriptor\r\n     * @param {TargetDescriptorTuple} - [target, descriptor] tuple.\r\n     * @returns {TargetDescriptorTuple} - Array of target and descriptor.\r\n     */\r\n    toEnumerableDescriptor = ([target, descriptor]) => {\r\n        descriptor.enumerable = true;\r\n        return [target, descriptor];\r\n    },\r\n\r\n    /**\r\n     * Returns an target and descriptor tuple from given.\r\n     * @function module:fjlMutable.toTargetDescriptorTuple\r\n     * @param targetOrTargetDescriptorTuple {(*|Array<*, *>)} - Target object or tuple of target and descriptor.\r\n     * @returns {(Array<*>|Array<*,*>)}\r\n     */\r\n    toTargetDescriptorTuple = targetOrTargetDescriptorTuple =>\r\n        isType('Array', targetOrTargetDescriptorTuple) ? // Strict type check for array\r\n            targetOrTargetDescriptorTuple : [targetOrTargetDescriptorTuple],\r\n\r\n    /**\r\n     * Allows you to define a \"typed\" property on given `target`.\r\n     * @function module:fjlMutable.defineProp\r\n     * @param Type {TypeRef} - {String|Function}\r\n     * @param target {TargetDescriptorTuple} - Target or array of target and descriptor ([target, descriptor]).\r\n     * @param propName {String}\r\n     * @param [defaultValue=undefined] {*}\r\n     * @returns {TargetDescriptorTuple}\r\n     */\r\n    defineProp = (Type, target, propName, defaultValue = undefined) => {\r\n        const [_target, _descriptor] = toTargetDescriptorTuple(target),\r\n            descriptor = _descriptor || createTypedDescriptor(Type, _target, propName);\r\n        Object.defineProperty(_target, propName, descriptor);\r\n        if (!isUndefined(defaultValue)) {\r\n            _target[propName] = defaultValue;\r\n        }\r\n        return [_target, descriptor];\r\n    },\r\n\r\n    /**\r\n     * Allows you to define a \"typed\", enumerated property on `target`.\r\n     * @function module:fjlMutable.defineEnumProp\r\n     * @param Type {TypeRef} - {String|Function}\r\n     * @param target {TargetDescriptorTuple} - Target or array of target and descriptor ([target, descriptor]).\r\n     * @param propName {String}\r\n     * @param [defaultValue=undefined] {*}\r\n     * @returns {TargetDescriptorTuple}\r\n     */\r\n    defineEnumProp = (Type, target, propName, defaultValue = undefined) => {\r\n        const [_target, _descriptor] = toTargetDescriptorTuple(target),\r\n            descriptor = _descriptor || createTypedDescriptor(Type, _target, propName);\r\n        return defineProp(\r\n            Type,\r\n            toEnumerableDescriptor([_target, descriptor]),\r\n            propName,\r\n            defaultValue\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Allows you to define multiple enum props at once on target.\r\n     * @function module:fjlMutable.defineEnumProps\r\n     * @param argsTuple {Array.<DefinePropArgsTuple>} - Array of argArrays for `defineEnumProp`.\r\n     * @param [target = undefined] {Target} - Target to use in internal calls if one is not provided but encountered 'argArray'.\r\n     * @returns {Array.<TargetDescriptorTuple>} - Results of each call to `defineEnumProp`.\r\n     */\r\n    defineEnumProps = curry(createDefinePropsMethod({enumerable: true})),\r\n\r\n    /**\r\n     * Allows you to define multiple props at once on target.\r\n     * @function module:fjlMutable.defineProps\r\n     * @param argsTuple {Array.<DefinePropArgsTuple>} - Array of argArrays for `defineProp`.\r\n     * @param [target = undefined] {Target} - Target to use in internal calls if one is not provided but encountered 'argArray'.\r\n     * @returns {Array.<TargetDescriptorTuple>} - Results of each call to `defineProp`.\r\n     * @curried\r\n     */\r\n    defineProps = curry(createDefinePropsMethod({enumerable: false}))\r\n\r\n;\r\n\r\n/** ============================================================= */\r\n/** Type definitions:                                             */\r\n/** ============================================================= */\r\n/**\r\n * @typedef {String|Function} TypeRef\r\n * @description Type reference.  Either actual type or type's name;  E.g., `Type.name`\r\n */\r\n\r\n/**\r\n * @typedef {*} Target\r\n */\r\n\r\n/**\r\n * @typedef {Object} Descriptor\r\n */\r\n\r\n/**\r\n * @typedef {Array<Target, Descriptor>} TargetDescriptorTuple\r\n */\r\n\r\n/**\r\n * @typedef {Array.<TypeRef, TargetDescriptorTuple, String, *>}  DefinePropArgsTuple\r\n * @description Arguments list for `defineProp` and/or `defineEnumProp` (note: some\r\n *  parts of array/tuple are options (namely the last two args));  E.g.,\r\n *  ```\r\n *  [String, [someTarget], 'somePropName', 'someDefaultValue] // ...\r\n *  ```\r\n */\r\n\r\n/**\r\n * @typedef {Function} PropsDefinerCall\r\n * @description Same type as `defineProp` and `defineEnumProp`\r\n * @param argsTuple {DefinePropArgsTuple}\r\n * @param target {Target}\r\n * @returns {Array.<TargetDescriptorTuple>}\r\n */\r\n"],"names":["createDefinePropsMethod","enumerable","operation","defineEnumProp","defineProp","argTuples","target","forEach","argTuple","TypeRef","propName","defaultValue","apply","createTypedDescriptor","Type","_value","get","set","value","errorIfNotType","toEnumerableDescriptor","descriptor","toTargetDescriptorTuple","targetOrTargetDescriptorTuple","isType","undefined","_target","_descriptor","Object","defineProperty","isUndefined","defineEnumProps","curry","defineProps"],"mappings":";;AAAA;;;;AAIA,AAEA;;;;;;;AAMA,SAASA,uBAAT,CAAkC;EAACC;CAAnC,EAAgD;QACtCC,SAAS,GAAGD,UAAU,GAAGE,cAAH,GAAoBC,UAAhD;SACO,CAACC,SAAD,EAAYC,MAAZ,KAAuB;IAC1BD,SAAS,CAACE,OAAV,CAAkBC,QAAQ,IAAI;YACpB,CAACC,OAAD,EAAUC,QAAV,EAAoBC,YAApB,IAAoCH,QAA1C;MACAI,KAAK,CAACV,SAAD,EAAY,CAACO,OAAD,EAAUH,MAAV,EAAkBI,QAAlB,EAA4BC,YAA5B,CAAZ,CAAL;KAFJ;WAIOL,MAAP;GALJ;;;AASJ;;;;;;;;;;AAWIO,qBAAqB,GAAG,CAACC,IAAD,EAAOR,MAAP,EAAeI,QAAf,KAA4B;MAC5CK,MAAJ;;SACO;IACHC,GAAG,EAAE,YAAY;aACND,MAAP;KAFD;IAIHE,GAAG,EAAE,UAAUC,KAAV,EAAiB;MAClBH,MAAM,GAAGI,cAAc,CAACL,IAAD,EAAOJ,QAAP,EAAiBJ,MAAjB,EAAyBY,KAAzB,CAAvB;;GALR;CAbD;;AAuBH;;;;;;;AAOAE,sBAAsB,GAAG,CAAC,CAACd,MAAD,EAASe,UAAT,CAAD,KAA0B;EAC/CA,UAAU,CAACpB,UAAX,GAAwB,IAAxB;SACO,CAACK,MAAD,EAASe,UAAT,CAAP;CAhCD;;AAmCH;;;;;;AAMAC,uBAAuB,GAAGC,6BAA6B,IACnDC,MAAM,CAAC,OAAD,EAAUD,6BAAV,CAAN;AACIA,6BADJ,GACoC,CAACA,6BAAD,CA3CrC;;AA6CH;;;;;;;;;AASAnB,UAAU,GAAG,CAACU,IAAD,EAAOR,MAAP,EAAeI,QAAf,EAAyBC,YAAY,GAAGc,SAAxC,KAAsD;QACzD,CAACC,OAAD,EAAUC,WAAV,IAAyBL,uBAAuB,CAAChB,MAAD,CAAtD;QACIe,UAAU,GAAGM,WAAW,IAAId,qBAAqB,CAACC,IAAD,EAAOY,OAAP,EAAgBhB,QAAhB,CADrD;;EAEAkB,MAAM,CAACC,cAAP,CAAsBH,OAAtB,EAA+BhB,QAA/B,EAAyCW,UAAzC;;MACI,CAACS,WAAW,CAACnB,YAAD,CAAhB,EAAgC;IAC5Be,OAAO,CAAChB,QAAD,CAAP,GAAoBC,YAApB;;;SAEG,CAACe,OAAD,EAAUL,UAAV,CAAP;CA7DD;;AAgEH;;;;;;;;;AASAlB,cAAc,GAAG,CAACW,IAAD,EAAOR,MAAP,EAAeI,QAAf,EAAyBC,YAAY,GAAGc,SAAxC,KAAsD;QAC7D,CAACC,OAAD,EAAUC,WAAV,IAAyBL,uBAAuB,CAAChB,MAAD,CAAtD;QACIe,UAAU,GAAGM,WAAW,IAAId,qBAAqB,CAACC,IAAD,EAAOY,OAAP,EAAgBhB,QAAhB,CADrD;;SAEON,UAAU,CACbU,IADa,EAEbM,sBAAsB,CAAC,CAACM,OAAD,EAAUL,UAAV,CAAD,CAFT,EAGbX,QAHa,EAIbC,YAJa,CAAjB;CA5ED;;AAoFH;;;;;;;AAOAoB,eAAe,GAAGC,KAAK,CAAChC,uBAAuB,CAAC;EAACC,UAAU,EAAE;CAAd,CAAxB,CA3FpB;;AA6FH;;;;;;;;AAQAgC,WAAW,GAAGD,KAAK,CAAChC,uBAAuB,CAAC;EAACC,UAAU,EAAE;CAAd,CAAxB,CArGhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}