{"version":3,"file":"fjl-mutable.js","sources":["../../src/fjlMutable.js"],"sourcesContent":["/**\r\n * @module fjlMutable\r\n * @note Custom jsdoc type definitions defined toward end of file.\r\n */\r\nimport {isUndefined, curry, apply, isType, errorIfNotType} from 'fjl';\r\n\r\n/**\r\n * Creates `defineProps` and `defineEnumProps` methods based on `{enumerable}` param.\r\n * @param {{enumerable: Boolean}}\r\n * @returns {function(*, *)|PropsDefinerCall}\r\n * @private\r\n */\r\nfunction createDefinePropsMethod ({enumerable}) {\r\n    const operation = enumerable ? defineEnumProp : defineProp;\r\n    return (argTuples, target) => {\r\n        argTuples.forEach(argTuple => {\r\n            const [TypeRef, propName, defaultValue] = argTuple;\r\n            apply(operation, [TypeRef, target, propName, defaultValue]);\r\n        });\r\n        return target;\r\n    };\r\n}\r\n\r\nexport const\r\n\r\n    /**\r\n     * Creates a descriptor for a property which is settable but throws\r\n     * errors when the `Type` is disobeyed.\r\n     * @function module:fjlMutable.createTypedDescriptor\r\n     * @param Type {TypeRef} - {String|Function}\r\n     * @param target {*}\r\n     * @param propName {String}\r\n     * @returns {Descriptor} - Property descriptor with just getter and setter.\r\n     */\r\n    createTypedDescriptor = (Type, target, propName) => {\r\n        let _value;\r\n        return {\r\n            get: function () {\r\n                return _value;\r\n            },\r\n            set: function (value) {\r\n                _value = errorIfNotType(Type, propName, target, value);\r\n            }\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns a target-descriptor tuple whose 'descriptor' will be set to\r\n     *  enumerable (`enumerable: true`).\r\n     * @function module:fjlMutable.toEnumerableDescriptor\r\n     * @param {TargetDescriptorTuple} - [target, descriptor] tuple.\r\n     * @returns {TargetDescriptorTuple} - Array of target and descriptor.\r\n     */\r\n    toEnumerableDescriptor = ([target, descriptor]) => {\r\n        descriptor.enumerable = true;\r\n        return [target, descriptor];\r\n    },\r\n\r\n    /**\r\n     * Returns an target and descriptor tuple from given.\r\n     * @function module:fjlMutable.toTargetDescriptorTuple\r\n     * @param targetOrTargetDescriptorTuple {(*|Array<*, *>)} - Target object or tuple of target and descriptor.\r\n     * @returns {(Array<*>|Array<*,*>)}\r\n     */\r\n    toTargetDescriptorTuple = targetOrTargetDescriptorTuple =>\r\n        isType('Array', targetOrTargetDescriptorTuple) ? // Strict type check for array\r\n            targetOrTargetDescriptorTuple : [targetOrTargetDescriptorTuple],\r\n\r\n    /**\r\n     * Allows you to define a \"typed\" property on given `target`.\r\n     * @function module:fjlMutable.defineProp\r\n     * @param Type {TypeRef} - {String|Function}\r\n     * @param target {TargetDescriptorTuple} - Target or array of target and descriptor ([target, descriptor]).\r\n     * @param propName {String}\r\n     * @param [defaultValue=undefined] {*}\r\n     * @returns {TargetDescriptorTuple}\r\n     */\r\n    defineProp = (Type, target, propName, defaultValue = undefined) => {\r\n        const [_target, _descriptor] = toTargetDescriptorTuple(target),\r\n            descriptor = _descriptor || createTypedDescriptor(Type, _target, propName);\r\n        Object.defineProperty(_target, propName, descriptor);\r\n        if (!isUndefined(defaultValue)) {\r\n            _target[propName] = defaultValue;\r\n        }\r\n        return [_target, descriptor];\r\n    },\r\n\r\n    /**\r\n     * Allows you to define a \"typed\", enumerated property on `target`.\r\n     * @function module:fjlMutable.defineEnumProp\r\n     * @param Type {TypeRef} - {String|Function}\r\n     * @param target {TargetDescriptorTuple} - Target or array of target and descriptor ([target, descriptor]).\r\n     * @param propName {String}\r\n     * @param [defaultValue=undefined] {*}\r\n     * @returns {TargetDescriptorTuple}\r\n     */\r\n    defineEnumProp = (Type, target, propName, defaultValue = undefined) => {\r\n        const [_target, _descriptor] = toTargetDescriptorTuple(target),\r\n            descriptor = _descriptor || createTypedDescriptor(Type, _target, propName);\r\n        return defineProp(\r\n            Type,\r\n            toEnumerableDescriptor([_target, descriptor]),\r\n            propName,\r\n            defaultValue\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Allows you to define multiple enum props at once on target.\r\n     * @function module:fjlMutable.defineEnumProps\r\n     * @param argsTuple {Array.<DefinePropArgsTuple>} - Array of argArrays for `defineEnumProp`.\r\n     * @param [target = undefined] {Target} - Target to use in internal calls if one is not provided but encountered 'argArray'.\r\n     * @returns {Array.<TargetDescriptorTuple>} - Results of each call to `defineEnumProp`.\r\n     */\r\n    defineEnumProps = curry(createDefinePropsMethod({enumerable: true})),\r\n\r\n    /**\r\n     * Allows you to define multiple props at once on target.\r\n     * @function module:fjlMutable.defineProps\r\n     * @param argsTuple {Array.<DefinePropArgsTuple>} - Array of argArrays for `defineProp`.\r\n     * @param [target = undefined] {Target} - Target to use in internal calls if one is not provided but encountered 'argArray'.\r\n     * @returns {Array.<TargetDescriptorTuple>} - Results of each call to `defineProp`.\r\n     * @curried\r\n     */\r\n    defineProps = curry(createDefinePropsMethod({enumerable: false}))\r\n\r\n;\r\n\r\n/** ============================================================= */\r\n/** Type definitions:                                             */\r\n/** ============================================================= */\r\n/**\r\n * @typedef {String|Function} TypeRef\r\n * @description Type reference.  Either actual type or type's name;  E.g., `Type.name`\r\n */\r\n\r\n/**\r\n * @typedef {*} Target\r\n */\r\n\r\n/**\r\n * @typedef {Object} Descriptor\r\n */\r\n\r\n/**\r\n * @typedef {Array<Target, Descriptor>} TargetDescriptorTuple\r\n */\r\n\r\n/**\r\n * @typedef {Array.<TypeRef, TargetDescriptorTuple, String, *>}  DefinePropArgsTuple\r\n * @description Arguments list for `defineProp` and/or `defineEnumProp` (note: some\r\n *  parts of array/tuple are options (namely the last two args));  E.g.,\r\n *  ```\r\n *  [String, [someTarget], 'somePropName', 'someDefaultValue] // ...\r\n *  ```\r\n */\r\n\r\n/**\r\n * @typedef {Function} PropsDefinerCall\r\n * @description Same type as `defineProp` and `defineEnumProp`\r\n * @param argsTuple {DefinePropArgsTuple}\r\n * @param target {Target}\r\n * @returns {Array.<TargetDescriptorTuple>}\r\n */\r\n"],"names":["createDefinePropsMethod","enumerable","operation","defineEnumProp","defineProp","argTuples","target","forEach","argTuple","TypeRef","propName","defaultValue","apply","createTypedDescriptor","Type","_value","get","set","value","errorIfNotType","toEnumerableDescriptor","descriptor","toTargetDescriptorTuple","targetOrTargetDescriptorTuple","isType","undefined","_target","_descriptor","Object","defineProperty","isUndefined","defineEnumProps","curry","defineProps"],"mappings":"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"}